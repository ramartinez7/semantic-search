import ora, { Ora } from 'ora';
import chalk from 'chalk';
import { basename } from 'path';
import { TokenUsage } from './nlp';

export interface IndexingStats {
  totalFiles: number;
  processedFiles: number;
  skippedFiles: number;
  errorFiles: number;
  startTime: number;
  currentFile?: string;
  totalTokens: {
    prompt: number;      // Input tokens sent to the API
    completion: number;  // Output tokens generated by the API
    total: number;
  };
}

export interface ProgressCallbacks {
  onStart?: (stats: IndexingStats) => void;
  onFileStart?: (filePath: string, stats: IndexingStats) => void;
  onFileComplete?: (filePath: string, stats: IndexingStats, duration: number) => void;
  onFileSkip?: (filePath: string, reason: string, stats: IndexingStats) => void;
  onFileError?: (filePath: string, error: Error, stats: IndexingStats) => void;
  onComplete?: (stats: IndexingStats) => void;
}

export class IndexingProgressManager {
  private stats: IndexingStats;
  private spinner: Ora | null = null;
  private callbacks: ProgressCallbacks;
  private verbose: boolean;
  private activeFiles: Map<string, { startTime: number; progress: string; spinner?: Ora }> = new Map();
  private processingAnimation = ['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'];
  private animationIndex = 0;

  constructor(totalFiles: number, callbacks: ProgressCallbacks = {}, verbose = false) {
    this.stats = {
      totalFiles,
      processedFiles: 0,
      skippedFiles: 0,
      errorFiles: 0,
      startTime: Date.now(),
      totalTokens: {
        prompt: 0,
        completion: 0,
        total: 0
      }
    };
    this.callbacks = callbacks;
    this.verbose = verbose;
  }

  start(): void {
    console.log(chalk.blue.bold(`📚 Starting indexing process for ${this.stats.totalFiles} files\n`));
    this.callbacks.onStart?.(this.stats);
  }

  startFile(filePath: string): void {
    this.stats.currentFile = filePath;
    const filename = basename(filePath);
    const progress = `${this.stats.processedFiles + this.stats.skippedFiles + this.stats.errorFiles + 1}/${this.stats.totalFiles}`;
    
    if (this.verbose) {
      // For concurrent processing, show a clean start message
      console.log(chalk.cyan(`[${progress}] ⚡ ${filename}`));
      // Store active file info
      this.activeFiles.set(filePath, { startTime: Date.now(), progress });
    } else {
      // For non-verbose mode, create individual spinner for each file
      const fileSpinner = ora({
        text: chalk.cyan(`[${progress}] Processing: ${filename}`),
        spinner: 'dots',
        color: 'cyan'
      }).start();
      
      // Store active file info with its spinner
      this.activeFiles.set(filePath, { startTime: Date.now(), progress, spinner: fileSpinner });
    }
    
    this.callbacks.onFileStart?.(filePath, this.stats);
  }

  updateProgress(message: string): void {
    // Update all active file spinners with the message
    for (const [filePath, fileInfo] of this.activeFiles) {
      if (fileInfo.spinner && !this.verbose) {
        fileInfo.spinner.text = chalk.cyan(message);
      }
    }
  }

  addTokens(tokens: TokenUsage): void {
    this.stats.totalTokens.prompt += tokens.prompt;
    this.stats.totalTokens.completion += tokens.completion;
    this.stats.totalTokens.total += tokens.total;
  }

  completeFile(filePath: string, duration: number, tokens?: { summary: TokenUsage; embedding: TokenUsage }): void {
    this.stats.processedFiles++;
    const filename = basename(filePath);
    const durationMs = Math.round(duration);
    
    // Remove from active files and get spinner if exists
    const activeFile = this.activeFiles.get(filePath);
    this.activeFiles.delete(filePath);
    
    if (tokens) {
      this.addTokens(tokens.summary);
      this.addTokens(tokens.embedding);
    }
    
    const tokenInfo = tokens ? 
      ` • ${tokens.summary.total + tokens.embedding.total} tokens (${tokens.summary.prompt + tokens.embedding.prompt} in, ${tokens.summary.completion + tokens.embedding.completion} out)` : '';
    const progressInfo = activeFile ? `[${activeFile.progress}]` : '';
    
    if (this.verbose) {
      console.log(chalk.green(`${progressInfo} ✅ ${filename} (${durationMs}ms${tokenInfo})`));
    } else {
      // Use the file's individual spinner
      if (activeFile?.spinner) {
        activeFile.spinner.succeed(chalk.green(`✅ ${filename} (${durationMs}ms${tokenInfo})`));
      }
    }
    
    this.callbacks.onFileComplete?.(filePath, this.stats, duration);
  }

  skipFile(filePath: string, reason: string): void {
    this.stats.skippedFiles++;
    const filename = basename(filePath);
    
    if (this.verbose) {
      console.log(chalk.yellow(`   ⏭️  ${filename} (${reason})`));
    } else {
      if (this.spinner) {
        this.spinner.info(chalk.yellow(`⏭️ Skipped: ${filename} (${reason})`));
        this.spinner = null;
      }
    }
    
    this.callbacks.onFileSkip?.(filePath, reason, this.stats);
  }

  errorFile(filePath: string, error: Error): void {
    this.stats.errorFiles++;
    const filename = basename(filePath);
    
    if (this.verbose) {
      console.log(chalk.red(`   ❌ Error: ${filename} - ${error.message}`));
    } else {
      if (this.spinner) {
        this.spinner.fail(chalk.red(`❌ Error: ${filename} - ${error.message}`));
        this.spinner = null;
      }
    }
    
    this.callbacks.onFileError?.(filePath, error, this.stats);
  }

  complete(): void {
    if (this.spinner) {
      this.spinner.stop();
      this.spinner = null;
    }

    const duration = Date.now() - this.stats.startTime;
    const durationSec = (duration / 1000).toFixed(1);
    
    console.log(chalk.blue('\n' + '═'.repeat(60)));
    console.log(chalk.green.bold('🎉 Indexing Complete!'));
    console.log(chalk.blue('═'.repeat(60)));
    
    // Statistics
    console.log(chalk.white('📊 Summary:'));
    console.log(`   ${chalk.green('✅ Processed:')} ${chalk.bold(this.stats.processedFiles.toString())} files`);
    
    if (this.stats.skippedFiles > 0) {
      console.log(`   ${chalk.yellow('⏭️  Skipped:')} ${chalk.bold(this.stats.skippedFiles.toString())} files`);
    }
    
    if (this.stats.errorFiles > 0) {
      console.log(`   ${chalk.red('❌ Errors:')} ${chalk.bold(this.stats.errorFiles.toString())} files`);
    }
    
    console.log(`   ${chalk.cyan('⏱️  Duration:')} ${chalk.bold(durationSec)}s`);
    
    if (this.stats.processedFiles > 0) {
      const avgTime = (duration / this.stats.processedFiles).toFixed(0);
      console.log(`   ${chalk.gray('📈 Avg/file:')} ${chalk.bold(avgTime)}ms`);
      
      const avgTokens = Math.round(this.stats.totalTokens.total / this.stats.processedFiles);
      console.log(`   ${chalk.gray('🔤 Avg tokens/file:')} ${chalk.bold(avgTokens)}`);
    }
    
    console.log(`   ${chalk.blue('🔤 Total tokens:')} ${chalk.bold(this.stats.totalTokens.total.toLocaleString())}`);
    console.log(`   ${chalk.gray('   • Input:')} ${chalk.bold(this.stats.totalTokens.prompt.toLocaleString())}`);
    console.log(`   ${chalk.gray('   • Output:')} ${chalk.bold(this.stats.totalTokens.completion.toLocaleString())}`);
    
    console.log(chalk.blue('═'.repeat(60)));
    
    this.callbacks.onComplete?.(this.stats);
  }

  getStats(): IndexingStats {
    return { ...this.stats };
  }

  isComplete(): boolean {
    return (this.stats.processedFiles + this.stats.skippedFiles + this.stats.errorFiles) >= this.stats.totalFiles;
  }

  getProgressPercentage(): number {
    const total = this.stats.processedFiles + this.stats.skippedFiles + this.stats.errorFiles;
    return Math.round((total / this.stats.totalFiles) * 100);
  }
}
